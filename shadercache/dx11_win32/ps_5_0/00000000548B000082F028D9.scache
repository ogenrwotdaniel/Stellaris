#define PIXEL_SHADER
#define SHADERQUALITY_HIGH
#define ALPHA_TEST
#define PDX_DIRECTX_11

#define PDX_POSITION SV_POSITION
#define PDX_COLOR SV_TARGET

#define mod( X, Y ) ( X % Y )

#define FIX_FLIPPED_UV( X ) ( X )

float3x3 CastTo3x3( in float4x4 M )
{
	return (float3x3)M;
}
#define Create3x3 float3x3
#define GetMatrixData( Matrix, row, col ) ( Matrix [ row ] [ col ] )

float2 vec2(float vValue) { return float2(vValue, vValue); }
float3 vec3(float vValue) { return float3(vValue, vValue, vValue); }
float4 vec4(float vValue) { return float4(vValue, vValue, vValue, vValue); }


struct STextureSampler2D
{
    Texture2D 		_Texture;
    SamplerState 	_Sampler;
};
STextureSampler2D CreateSampler2D( Texture2D Texture, SamplerState Sampler )
{
    STextureSampler2D ret = { Texture, Sampler };
    return ret;
}

struct STextureSamplerCube
{
    TextureCube 	_Texture;
    SamplerState 	_Sampler;
};
STextureSamplerCube CreateSamplerCube( TextureCube Texture, SamplerState Sampler )
{
    STextureSamplerCube ret = { Texture, Sampler };
    return ret;
}

#define TextureSampler2D STextureSampler2D

#define sampler2DShadow STextureSampler2D
#define sampler2D STextureSampler2D

#define tex2D(samp,uv) samp._Texture.Sample(samp._Sampler, uv)
#define tex2Dlod(samp,uv_lod) samp._Texture.SampleLevel(samp._Sampler, (uv_lod).xy, (uv_lod).w)
#define tex2Dlod0(samp,uv_lod) samp._Texture.SampleLevel(samp._Sampler, (uv_lod).xy, 0)
#define tex2Dbias(samp,uv_bias) samp._Texture.SampleBias(samp._Sampler, (uv_bias).xy, (uv_bias).w)
#define tex2Dproj(samp,uv_proj) samp._Texture.SampleLevel(samp._Sampler, (uv_proj).xy / (uv_proj).w, 0)
#define tex2Dgrad(samp,uv,ddx,ddy) samp._Texture.SampleGrad(samp._Sampler, uv, ddx, ddy)

#define texCUBE(samp,uv) samp._Texture.Sample(samp._Sampler, uv)
#define texCUBElod(samp,uv_lod) samp._Texture.SampleLevel(samp._Sampler, (uv_lod).xyz, (uv_lod).w)
#define texCUBEbias(samp,uv_bias) samp._Texture.SampleBias(samp._Sampler, (uv_bias).xyz, (uv_bias).w)

#define uintIfSupported uint

Texture2D DiffuseMap_Texture : register(t0);
SamplerState DiffuseMap_Sampler : register(s0);
#define DiffuseMap CreateSampler2D(DiffuseMap_Texture, DiffuseMap_Sampler)
Texture2D SpecularMap_Texture : register(t1);
SamplerState SpecularMap_Sampler : register(s1);
#define SpecularMap CreateSampler2D(SpecularMap_Texture, SpecularMap_Sampler)
Texture2D NormalMap_Texture : register(t2);
SamplerState NormalMap_Sampler : register(s2);
#define NormalMap CreateSampler2D(NormalMap_Texture, NormalMap_Sampler)
Texture2D FlagMap_Texture : register(t3);
SamplerState FlagMap_Sampler : register(s3);
#define FlagMap CreateSampler2D(FlagMap_Texture, FlagMap_Sampler)
TextureCube EnvironmentMap_Texture : register(t4);
SamplerState EnvironmentMap_Sampler : register(s4);
#define EnvironmentMap CreateSamplerCube(EnvironmentMap_Texture, EnvironmentMap_Sampler)
Texture2D LightIndexMap_Texture : register(t5);
SamplerState LightIndexMap_Sampler : register(s5);
#define LightIndexMap CreateSampler2D(LightIndexMap_Texture, LightIndexMap_Sampler)
Texture2D LightDataMap_Texture : register(t6);
SamplerState LightDataMap_Sampler : register(s6);
#define LightDataMap CreateSampler2D(LightDataMap_Texture, LightDataMap_Sampler)
TextureCube LavaNoise_Texture : register(t7);
SamplerState LavaNoise_Sampler : register(s7);
#define LavaNoise CreateSamplerCube(LavaNoise_Texture, LavaNoise_Sampler)
Texture2D LavaDiffuse_Texture : register(t8);
SamplerState LavaDiffuse_Sampler : register(s8);
#define LavaDiffuse CreateSampler2D(LavaDiffuse_Texture, LavaDiffuse_Sampler)
Texture2D StoneDiffuse_Texture : register(t9);
SamplerState StoneDiffuse_Sampler : register(s9);
#define StoneDiffuse CreateSampler2D(StoneDiffuse_Texture, StoneDiffuse_Sampler)
Texture2D CustomTexture_Texture : register(t10);
SamplerState CustomTexture_Sampler : register(s10);
#define CustomTexture CreateSampler2D(CustomTexture_Texture, CustomTexture_Sampler)
Texture2D CustomTexture2_Texture : register(t11);
SamplerState CustomTexture2_Sampler : register(s11);
#define CustomTexture2 CreateSampler2D(CustomTexture2_Texture, CustomTexture2_Sampler)
Texture2D PortraitCharacter_Texture : register(t12);
SamplerState PortraitCharacter_Sampler : register(s12);
#define PortraitCharacter CreateSampler2D(PortraitCharacter_Texture, PortraitCharacter_Sampler)
Texture2D PortraitClothes_Texture : register(t13);
SamplerState PortraitClothes_Sampler : register(s13);
#define PortraitClothes CreateSampler2D(PortraitClothes_Texture, PortraitClothes_Sampler)
Texture2D PortraitHair_Texture : register(t14);
SamplerState PortraitHair_Sampler : register(s14);
#define PortraitHair CreateSampler2D(PortraitHair_Texture, PortraitHair_Sampler)
Texture2D PortraitEvolutionDecal_Texture : register(t15);
SamplerState PortraitEvolutionDecal_Sampler : register(s15);
#define PortraitEvolutionDecal CreateSampler2D(PortraitEvolutionDecal_Texture, PortraitEvolutionDecal_Sampler)
cbuffer dx11_cb0 : register(b0)
{
	float4x4 ViewProjectionMatrix;
	float3 vCamPos;
	float3 vCamRightDir;
	float3 vCamLookAtDir;
	float3 vCamUpDir;
	float3 HdrRange_Time_ClipHeight;
	float4 SystemLightPosRadius;
	float4 SystemLightColorFalloff;
	float3 SystemBackLightDiffuse;
	float3 AmbientDiffuse;
	float CubemapIntensity;
	float3 CamLightDiffuse[3];
	float3 RimLightDiffuse;
}
cbuffer dx11_cb1 : register(b1)
{
	float4x4 WorldMatrix;
	float4 Erosion;
	float2 vUVAnimationDir;
	float vUVAnimationTime;
	float vBloomFactor;
	float4 AtmosphereColor;
	float AtmosphereIntensity;
	float AtmosphereWidth;
	float Sensor;
	float Colonized;
	float vPlanetDissolveTime;
	float3 vPlanetDissolveColorMult;
}
cbuffer dx11_cb3 : register(b3)
{
	float4 ShadowMapTextureMatrix0XAxis;
	float4 ShadowMapTextureMatrix0YAxis;
	float4 ShadowMapTextureMatrix0ZAxis;
	float4 ShadowMapTextureMatrix1XAxis;
	float4 ShadowMapTextureMatrix1YAxis;
	float4 ShadowMapTextureMatrix1ZAxis;
	float4 ShadowMapTextureMatrix2XAxis;
	float4 ShadowMapTextureMatrix2YAxis;
	float4 ShadowMapTextureMatrix2ZAxis;
	float4 ShadowMapTextureMatrix3XAxis;
	float4 ShadowMapTextureMatrix3YAxis;
	float4 ShadowMapTextureMatrix3ZAxis;
}
cbuffer dx11_cb4 : register(b4)
{
	float4 GridStart_InvCellSize;
}
struct VS_INPUT_PDXMESHSTANDARD
{
	float3 vPosition : POSITION;
	float3 vNormal : TEXCOORD0;
	float4 vTangent : TEXCOORD1;
	float2 vUV0 : TEXCOORD2;
#ifdef PDX_MESH_UV1
	float2 vUV1 : TEXCOORD3;
#endif
};
struct VS_INPUT_PDXMESHSTANDARD_SKINNED
{
	float3 vPosition : POSITION;
	float3 vNormal : TEXCOORD0;
	float4 vTangent : TEXCOORD1;
	float2 vUV0 : TEXCOORD2;
#ifdef PDX_MESH_UV1
	float2 vUV1 : TEXCOORD3;
#endif
	uint4 vBoneIndex : TEXCOORD4;
	float3 vBoneWeight : TEXCOORD5;
};
struct VS_OUTPUT_PDXMESHSTANDARD
{
	float4 vPosition : PDX_POSITION;
	float3 vNormal : TEXCOORD0;
	float3 vTangent : TEXCOORD1;
	float3 vBitangent : TEXCOORD2;
	float2 vUV0 : TEXCOORD3;
	float2 vUV1 : TEXCOORD4;
	float4 vPos : TEXCOORD5;
	float4 vSphere : TEXCOORD6;
	float3 vObjectNormal : TEXCOORD7;
};
struct VS_OUTPUT_PDXMESHSHADOW
{
	float4 vPosition : PDX_POSITION;
	float4 vDepthUV0 : TEXCOORD0;
};
struct VS_INPUT_DEBUGNORMAL
{
	float3 vPosition : POSITION;
	float3 vNormal : TEXCOORD0;
	float4 vTangent : TEXCOORD1;
	float2 vUV0 : TEXCOORD2;
	float2 vUV1 : TEXCOORD3;
	float vOffset : TEXCOORD6;
};
struct VS_INPUT_DEBUGNORMAL_SKINNED
{
	float3 vPosition : POSITION;
	float3 vNormal : TEXCOORD0;
	float4 vTangent : TEXCOORD1;
	float2 vUV0 : TEXCOORD2;
	float2 vUV1 : TEXCOORD3;
	uint4 vBoneIndex : TEXCOORD4;
	float3 vBoneWeight : TEXCOORD5;
	float vOffset : TEXCOORD6;
};
struct VS_OUTPUT_DEBUGNORMAL
{
	float4 vPosition : PDX_POSITION;
	float2 vUV0 : TEXCOORD0;
	float vOffset : TEXCOORD1;
};
struct VS_OUTPUT_PDXMESHNAVIGATIONBUTTON
{
	float4 vPosition : PDX_POSITION;
	float2 vUV0 : TEXCOORD0;
	float4 vPos : TEXCOORD1;
};
struct VS_OUTPUT_PDXMESHSHIELD
{
	float4 vPosition : PDX_POSITION;
	float2 vUV0 : TEXCOORD0;
	float4 vPos : TEXCOORD1;
};
// --------------------------------------------------------------
// ------------------    Light          -------------------------
// --------------------------------------------------------------
static const float3 SUN_DIFFUSE					= float3( 0.226f, 0.182f, 0.36f );


// --------------------------------------------------------------
// ------------------    HDR          	-------------------------
// --------------------------------------------------------------
static const float3 LUMINANCE_VECTOR  			= float3(0.2125f, 0.7154f, 0.0721f);


// --------------------------------------------------------------
// ------------------    Specular       -------------------------
// --------------------------------------------------------------
static const float SPECULAR_WIDTH 				= 15.0f;
static const float SPECULAR_MULTIPLIER			= 1.0f;
static const float MAP_SPECULAR_WIDTH 			= 15.0f;
static const float MAP_SPECULAR_MULTIPLIER		= 0.05f;


// --------------------------------------------------------------
// ------------------       ROADS       -------------------------
// --------------------------------------------------------------
static const float ROAD_TILE_FREQ				= 16.0f;
static const float ROAD_FADE_START				= 1.0f;
static const float ROAD_FADE_END				= 4.0f;

static const float ROAD_MAXIMAP_TILE_FREQ		= 30.f;
static const float ROAD_MAXIMAP_EXTRA_WIDTH		= 0.3f;

static const float ROAD_MINIMAP_TILE_FREQ		= 15.f;
static const float ROAD_MINIMAP_EXTRA_WIDTH		= 0.0f;


// --------------------------------------------------------------
// ------------------       COMBAT       ------------------------
// --------------------------------------------------------------
static const float COMBAT_OUTSIDE_BOUNDS_BRIGHTNESS	= 0.45f;
static const float COMBAT_INSIDE_BOUNDS_BRIGHTNESS	= 0.99f;
static const float COMBAT_BOUNDS_SHARPNESS 			= 0.1f;
static const float COMBAT_BOUNDS_BORDER_SHARPNESS	= 3.0f;


// --------------------------------------------------------------
// ------------------    WATER          -------------------------
// --------------------------------------------------------------
static const float 	WATER_TILE					= 1.8f;
static const float 	WATER_TIME_SCALE			= 0.03f;
static const float	WATER_FOG_START				= 16.5f;
static const float	WATER_FOG_END				= 19.7f;

static const float WATER_HEIGHT 				= 20.0f;
static const float WATER_HEIGHT_RECP 			= 1.0f / WATER_HEIGHT;
static const float WATER_HEIGHT_RECP_SQUARED 	= WATER_HEIGHT_RECP * WATER_HEIGHT_RECP;

static const float HEL_WATER_SCALE				= 1.2f;
static const float HEL_WATER_SPEED 				= 0.03f;
static const float HEL_WATER_GLOW_NOISE_SPEED	= 0.08f;
static const float HEL_WATER_GLOW_NOISE_SCALE   = 0.006f;


// --------------------------------------------------------------
// ------------------    SHADOW         -------------------------
// --------------------------------------------------------------
static const float  SHADOW_WEIGHT_TERRAIN    	= 1.0f;
static const float  SHADOW_WEIGHT_WATER   		= 1.0f;
static const float  SHADOW_WEIGHT_RIVER   		= 1.0f;
static const float  SHADOW_WEIGHT_TREE   		= 1.0f;
static const float  SHADOW_WEIGHT_ROAD   		= 1.0f;
static const float  SHADOW_WEIGHT_MESH   		= 1.0f;

// --------------------------------------------------------------
// -------------    RIM LIGHT (PDXMESH)   -----------------------
// --------------------------------------------------------------
static const float 	RIM_START 		= 0.6f;
static const float 	RIM_END 		= 1.0f;
static const float4 RIM_COLOR 		= float4( 0.3f, 0.6f, 0.8f, 0.0f );

// --------------------------------------------------------------
// -------------    GREYING OUT   -------------------------------
// --------------------------------------------------------------
static const float3 GREY_OUT_VECTOR     = float3( 0.212671f, 0.715160f, 0.072169f );
static const float GREY_OUT_GREYNESS    = 0.85f;    // [0.0f, 1.0f] 0.0f - the tint is not changed, 1.0f - the tint is completely removed
static const float GREY_OUT_BRIGHTNESS  = 0.75;     // [0.0f, 1.0f] 0.0f - completely black, 1.0f - the same brighnes as before graying out

float3 ToGamma(float3 aLinear)
{
	return pow(abs(aLinear), vec3(1.0/2.2));
}

float3 ToLinear(float3 aGamma)
{
	return pow(abs(aGamma), vec3(2.2));
}

float4 ToLinear(float4 aGamma)
{
	return float4(ToLinear(aGamma.rgb), aGamma.a);
}

float Rand2DTo1D(float2 value, float2 dir)
{
    float2 smallValue = sin(value);
    float rand = dot(smallValue, dir);
    rand = frac(sin(rand) * 143745.3413f);
    return rand;
}

float Rand2DTo1D(float2 value)
{
	return Rand2DTo1D(value, float2(15.42f, 81.344f));
}

float2 Rand2DTo2D(float2 value)
{
    return float2(Rand2DTo1D(value, float2(13.251f, 76.129f)), Rand2DTo1D(value, float2(51.117f, 81.524f) ) );
}

float2 VoronoiNoise2D(float3 worldPos, float cellSize, float2 offsetPos)
{
    float2 value = worldPos.xy / cellSize ;
    value += offsetPos;
    float2 baseCell = floor(value);
    float minDistToCell = 200.0f;
    float2 closestCell;
	
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            float2 cell = baseCell + float2(x, y);
			float2 cellPos = cell + Rand2DTo2D(cell);
            float distToCell = length(cellPos - value);
            if (distToCell < minDistToCell)
            {
                minDistToCell = distToCell;
                closestCell = cell;
            }
        }
    }
    return float2(minDistToCell, Rand2DTo1D(closestCell) );
}

float2 VoronoiNoise2D(float3 worldPos, float cellSize)
{
	return VoronoiNoise2D(worldPos, cellSize, float2(0.0f, 0.0f));
}

struct STriplanarMapping
	{
	float2 _UvX;
	float2 _UvY;
	float2 _UvZ;
	float2 _FlipX;
	float2 _FlipY;
	float2 _FlipZ;
	float3 _BlendFactor;
	};

STriplanarMapping CalcTriplanarMapping( in float3 ObjectNormal, in float3 ObjectSpacePos, in float TilingScale ) 
{
	// From: https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a but slightly adjusted to fit our purpose
	STriplanarMapping Out;
	//Calculate tri-planar blend factors
	Out._BlendFactor.x = saturate(pow(abs( ObjectNormal.x ), 3.0f ) );
	Out._BlendFactor.y = saturate(pow(abs( ObjectNormal.y ), 3.0f ) );
	Out._BlendFactor.z = saturate(pow(abs( ObjectNormal.z ), 3.0f ) );
	Out._BlendFactor /= max( dot( Out._BlendFactor, vec3( 1.0f ) ), 0.0001f);

	Out._FlipX = float2( sign( ObjectNormal.x ), -1.0f );
	Out._FlipY = float2( 1.0f, -sign( ObjectNormal.y ) );
	Out._FlipZ = float2( -sign( ObjectNormal.z ), -1.0f );

	//float TilingScale = 0.1f; //Scale the tiling value down a bit so that artists have an easier value to tweak
	//The Uvs have been swapped around to make a directional pattern look better
	Out._UvX = float2( ObjectSpacePos.z, ObjectSpacePos.y ) * Out._FlipX * TilingScale;
	Out._UvY = float2( ObjectSpacePos.z, ObjectSpacePos.x ) * Out._FlipY * TilingScale;
	Out._UvZ = float2( ObjectSpacePos.x, ObjectSpacePos.y ) * Out._FlipZ * TilingScale;

	return Out;
}

float4 SampleColorTriplanar( in sampler2D Sampler, in STriplanarMapping Mapping )
{
    float4 color = vec4( 0.0f );
    if ( Mapping._BlendFactor.x > 0.0f )
	{
        color += tex2D( Sampler, Mapping._UvX ) * Mapping._BlendFactor.x;
	}
    if ( Mapping._BlendFactor.y > 0.0f )
	{
        color += tex2D( Sampler, Mapping._UvY ) * Mapping._BlendFactor.y;
	}
    if ( Mapping._BlendFactor.z > 0.0f )
	{
        color += tex2D( Sampler, Mapping._UvZ ) * Mapping._BlendFactor.z;
	}
    return color;
}

bool AreEqual( in float4 Left, in float4 Right, in float Precision )
{
	return ( ( abs( Left.x - Right.x ) < Precision )
		&& ( abs( Left.y - Right.y ) < Precision )
		&& ( abs( Left.z - Right.z ) < Precision )
		&& ( abs( Left.w - Right.w ) < Precision ) );
}

	//-------------------------------
	// Greying out ------------------
	//-------------------------------
	
	float3 GreyOutDot( in float3 source )
	{
		float grey = dot( source.rgb, GREY_OUT_VECTOR );
		return float3( grey, grey, grey );
	}
	
	float3 GreyOutDotPow2( in float3 source )
	{
		float grey = dot( source.rgb, GREY_OUT_VECTOR );
		grey = pow( grey, 2 );
		return float3( grey, grey, grey );
	}
	
	float3 GreyOutDotLerp( in float3 source, in float scalar )
	{
		float grey = dot( source.rgb, GREY_OUT_VECTOR );
		return lerp( float3( grey, grey, grey ), source, scalar );
	}

	float3 GreyOutLuminosity( in float3 source, in float factor, in float brightness )
	{
		float grey = GREY_OUT_VECTOR.r * source.r + GREY_OUT_VECTOR.g * source.g + GREY_OUT_VECTOR.b * source.b;

		float3 result;
		result.r = grey * factor + source.r * ( 1.0f - factor );
		result.g = grey * factor + source.g * ( 1.0f - factor );
		result.b = grey * factor + source.b * ( 1.0f - factor );

		return result * brightness;
	}

static const int PDXMESH_MAX_INFLUENCE = 4;

// Photoshop filters, kinda...
	float3 Hue( float H )
	{
		float X = 1 - abs( ( mod( H, 2 ) ) - 1 );
		if ( H < 1.0f )			return float3( 1.0f,    X, 0.0f );
		else if ( H < 2.0f )	return float3(    X, 1.0f, 0.0f );
		else if ( H < 3.0f )	return float3( 0.0f, 1.0f,    X );
		else if ( H < 4.0f )	return float3( 0.0f,    X, 1.0f );
		else if ( H < 5.0f )	return float3(    X, 0.0f, 1.0f );
		else					return float3( 1.0f, 0.0f,    X );
	}

	float3 FastHueShift( in float3 color, in float hue )
	{
		float3 k = vec3( 0.57735 ); // 1/sqrt(3)
		float cosAngle = cos( hue );
		return float3( color * cosAngle + cross( k, color ) * sin( hue ) + k * dot( k, color ) * ( 1.0 - cosAngle ) ); // Using Rodrigues' rotation formula
	}


	float3 HSVtoRGB( in float3 aHSV )
	{
		float3 rgb;
		if ( aHSV.y != 0.0f )
		{
			float C = aHSV.y * aHSV.z;
			rgb = clamp( Hue( aHSV.x ) * C + ( aHSV.z - C ), 0.0f, 1.0f );
		}
		else
		{
			rgb = saturate( aHSV.zzz );
		}
		
		return rgb;
	}

	float3 RGBtoHSV( in float3 RGB )
	{
		float Cmax = max( RGB.r, max( RGB.g, RGB.b ) );
		float Cmin = min( RGB.r, min( RGB.g, RGB.b ) );
		float diff = Cmax - Cmin;

		float H = 0.0;
		float S = 0.0;
		if (diff != 0.0)
		{
			S = diff / Cmax;

			if (Cmax == RGB.r)
				H = (RGB.g - RGB.b) / diff + 6.0;
			else if (Cmax == RGB.g)
				H = (RGB.b - RGB.r) / diff + 2.0;
			else
				H = (RGB.r - RGB.g) / diff + 4.0;
		}

		return float3(H, S, Cmax);
	}


	float3 GetOverlay( float3 vColor, float3 vOverlay, float vOverlayPercent )
	{
		float3 res;
		res.r = vOverlay.r < .5 ? (2 * vOverlay.r * vColor.r) : (1 - 2 * (1 - vOverlay.r) * (1 - vColor.r));
		res.g = vOverlay.g < .5 ? (2 * vOverlay.g * vColor.g) : (1 - 2 * (1 - vOverlay.g) * (1 - vColor.g));
		res.b = vOverlay.b < .5 ? (2 * vOverlay.b * vColor.b) : (1 - 2 * (1 - vOverlay.b) * (1 - vColor.b));

		return lerp( vColor, res, vOverlayPercent );
	}

	float3 Levels( float3 vInColor, float vMinInput, float vMaxInput )
	{
		float3 vRet = saturate( vInColor - vMinInput );
		vRet /= vMaxInput - vMinInput;
		return saturate( vRet );
	}
		static const float3 STANDARD_vDiffuseLight = float3( 1.4f, 1.2f, 1.0f );
	static const float  STANDARD_vIntensity    = 1.f;
	static const float STANDARD_HDR_RANGE 	= 0.9f;
	static const float MAX_SPECULAR_NORMALIZATION_FACTOR = 5.f;

	const static float SNOW_RIDGE_START_HEIGHT 	= 22.0f;
	const static float SNOW_NORMAL_START 	= 0.3f;
	const static float3 SNOW_COLOR = float3( 0.7f, 0.7f, 0.8f );

	float3 ApplySnow( float3 vColor, float3 vPos, inout float3 vNormal, inout float vSpecular, inout float vSpecularPower, float vIsSnow, in sampler2D SnowDiffuse )
	{
		float vNormalFade = saturate( 0.2f + saturate( ( vNormal.y - SNOW_NORMAL_START ) * 1.0f ) );

		float vNoise = tex2D( SnowDiffuse, ( vPos.xz + 0.5f ) / 30.0f  ).r;
		float vSnowTexture = tex2D( SnowDiffuse, ( vPos.xz + 0.5f ) / 10.0f  ).r;


		//Increase snow on ridges
		//vNoise -= saturate( vPos.y - SNOW_RIDGE_START_HEIGHT )*( saturate( (vNormal.y-0.9f) * 20.0f )*vIsSnow );
		//vNoise = saturate( vNoise );

		float vSnow = saturate( ( vIsSnow - vNoise ) * 2.0f ) * vNormalFade;
		float vFrost = saturate( vIsSnow - saturate( vNoise - 0.5f ) );

		vColor = lerp( vColor, SNOW_COLOR * ( 0.9f + 0.1f * vSnowTexture), saturate( vSnow + vFrost * 0.5f ) );

		vSpecular += vSnow * 0.2f;
		vSpecularPower *= 1.f - vFrost * 0.9f;
		return vColor;
	}

	float3 UnpackNormal( in sampler2D NormalTex, float2 uv )
	{
		float3 vNormalSample = normalize( tex2D( NormalTex, uv ).rgb - 0.5f );
		vNormalSample.g = -vNormalSample.g;
		return vNormalSample;
	}

	float3 GetCloudColor( float3 vPosition, float vTime, in sampler2D CloudTexture )
	{
		float2 vCloudUV = vPosition.xz * 0.002f;
		vCloudUV.x += vTime * 0.0011f;
		vCloudUV.y += vTime * 0.0031f;
		float3 vCloud = tex2D( CloudTexture, vCloudUV ).rgb;
		vCloudUV *= 1.1f;
		vCloudUV.x -= vTime * 0.0007f;
		return min( vCloud, tex2D( CloudTexture, vCloudUV ).rgb );
	}

	struct PointLight
	{
		float3 _Position;
		float _Radius;
		float3 _Color;
		float _Falloff;
	};

	PointLight GetPointLight(float4 PositionAndRadius, float4 ColorAndFalloff)
	{
		PointLight pointLight;
		pointLight._Position = PositionAndRadius.xyz;
		pointLight._Radius = PositionAndRadius.w;
		pointLight._Color = ColorAndFalloff.xyz;
		pointLight._Falloff = ColorAndFalloff.w;
		return pointLight;
	}

	struct LightingProperties
	{
		float3 _WorldSpacePos;
		float3 _ToCameraDir;
		float3 _Normal;
		float3 _Diffuse;

		float3 _SpecularColor;
		float _Glossiness;
		float _NonLinearGlossiness;
	};
	// Direct lighting
	float3 FresnelSchlick(float3 SpecularColor, float3 E, float3 H)
	{
		return SpecularColor + (vec3(1.0f) - SpecularColor) * pow(1.0 - saturate(dot(E, H)), 5.0);
	}

	// Indirect lighting
	float3 FresnelGlossy(float3 SpecularColor, float3 E, float3 N, float Smoothness)
	{
		return SpecularColor + (max(vec3(Smoothness), SpecularColor) - SpecularColor) * pow(1.0 - saturate(dot(E, N)), 5.0);
	}

	float3 MetalnessToDiffuse(float MetalnessIn, float3 DiffuseIn)
	{
		return lerp(DiffuseIn, vec3(0.0), MetalnessIn);
	}

	float3 MetalnessToSpec(float MetalnessIn, float3 DiffuseIn, float SpecIn)
	{
		return lerp(vec3(SpecIn), DiffuseIn, MetalnessIn);
	}

	//------------------------------
	// Phong -----------------------
	//------------------------------
	float3 CalculatePBRSpecularPower( float3 vPos, float3 vNormal, float3 vMaterialSpecularColor, float vSpecularPower, float3 vLightColor, float3 vLightDirIn )
	{
		float3 H = normalize( normalize( vCamPos - vPos ) + -vLightDirIn );
		float NdotH = saturate( dot( H, vNormal ) );
		float NdotL = saturate( dot( -vLightDirIn, vNormal ) );
		float3 vSpecularColor = vLightColor * saturate( pow( NdotH, vSpecularPower ) * SPECULAR_MULTIPLIER ) * vMaterialSpecularColor;
		vSpecularColor = FresnelSchlick( vMaterialSpecularColor * SPECULAR_MULTIPLIER, -vLightDirIn, H) * ((vSpecularPower + 2) / 8 ) * saturate( pow( NdotH, vSpecularPower ) ) * NdotL * vLightColor;
		return vSpecularColor;
	}

	float3 CalculateLight( float3 vNormal, float3 vLightDirection, float3 vLightIntensity )
	{
		float NdotL = dot( vNormal, -vLightDirection );
		return max(NdotL, 0.0) * vLightIntensity;
	}

	void PhongPointLight(PointLight aPointlight, LightingProperties aProperties, inout float3 aDiffuseLightOut, inout float3 aSpecularLightOut)
	{
		float3 lightdir = aProperties._WorldSpacePos - aPointlight._Position;
		float lightdist = length(lightdir);

		float vLightIntensity = saturate((aPointlight._Radius - lightdist) / aPointlight._Falloff);
		if (vLightIntensity > 0)
		{
			lightdir /= lightdist;
			aDiffuseLightOut += CalculateLight(aProperties._Normal, lightdir, aPointlight._Color * vLightIntensity);
			aSpecularLightOut += CalculatePBRSpecularPower(aProperties._WorldSpacePos, aProperties._Normal, aProperties._SpecularColor, aProperties._Glossiness, aPointlight._Color * vLightIntensity, lightdir);
		}
	}



	//------------------------------
	// Blinn-Phong -----------------
	//------------------------------
	float GetNonLinearGlossiness(float aGlossiness)
	{
		return exp2(11.0 * aGlossiness); //exp2(GlossScale * Gloss + GlossBias)
	}

	float GetEnvmapMipLevel(float aGlossiness)
	{
		return (1.0 - aGlossiness) * (8.0);
	}

	void ImprovedBlinnPhong(float3 aLightColor, float3 aToLightDir, LightingProperties aProperties, out float3 aDiffuseLightOut, out float3 aSpecularLightOut)
	{
		float3 H = normalize(aProperties._ToCameraDir + aToLightDir);
		float NdotL = saturate(dot(aProperties._Normal, aToLightDir));
		float NdotH = saturate(dot(aProperties._Normal, H));

		float normalization = (aProperties._NonLinearGlossiness + 2.0) / 8.0;

		//Hack for Stellaris to avoid super-bright specularity that causes bloom
		normalization = min( normalization, MAX_SPECULAR_NORMALIZATION_FACTOR );

		float3 specColor = normalization * pow(NdotH, aProperties._NonLinearGlossiness) * FresnelSchlick(aProperties._SpecularColor, aToLightDir, H);

		aDiffuseLightOut = aLightColor * NdotL;
		aSpecularLightOut = specColor * aLightColor * NdotL;

		//hack to fix unwanted specularity when glossiness == 0
		aSpecularLightOut *= saturate( smoothstep( aProperties._Glossiness, 0.f, 0.05f ) );
	}

	// TODO other, square, falloff?
	void ImprovedBlinnPhongPointLight(PointLight aPointlight, LightingProperties aProperties, inout float3 aDiffuseLightOut, inout float3 aSpecularLightOut)
	{
		float3 posToLight = aPointlight._Position - aProperties._WorldSpacePos;
		float lightDistance = length(posToLight);

		float lightIntensity = saturate((aPointlight._Radius - lightDistance) / aPointlight._Falloff);
		if (lightIntensity > 0)
		{
			float3 toLightDir = posToLight / lightDistance;
			float3 diffLight;
			float3 specLight;
			ImprovedBlinnPhong(aPointlight._Color * lightIntensity, toLightDir, aProperties, diffLight, specLight);
			aDiffuseLightOut += diffLight;
			aSpecularLightOut += specLight;
		}
	}



	//-------------------------------
	// Common lighting functions ----
	//-------------------------------
	void CalculatePointLight(PointLight aPointlight, LightingProperties aProperties, inout float3 aDiffuseLightOut, inout float3 aSpecularLightOut)
	{
	#ifdef PDX_LEGACY_BLINN_PHONG
		PhongPointLight(aPointlight, aProperties, aDiffuseLightOut, aSpecularLightOut);
	#else
		ImprovedBlinnPhongPointLight(aPointlight, aProperties, aDiffuseLightOut, aSpecularLightOut);
	#endif
	}

	void CalculateSystemPointLight(LightingProperties aProperties, float aShadowFactor, inout float3 aDiffuseLightOut, inout float3 aSpecularLightOut)
	{
		PointLight systemPointlight = GetPointLight(SystemLightPosRadius, SystemLightColorFalloff);
		float3 diffLight = vec3(0.0);
		float3 specLight = vec3(0.0);
		CalculatePointLight(systemPointlight, aProperties, diffLight, specLight);
		aDiffuseLightOut += diffLight * aShadowFactor;
		aSpecularLightOut += specLight * aShadowFactor;

		#ifdef IS_PLANET
			float3 vLightDir = normalize( systemPointlight._Position - aProperties._WorldSpacePos );
			diffLight = CalculateLight( aProperties._Normal, vLightDir, SystemBackLightDiffuse );
			aDiffuseLightOut += diffLight * aShadowFactor;
		#endif
	}

	float3 ComposeLight(LightingProperties aProperties, float aAmbientIntensity, float3 aDiffuseLight, float3 aSpecularLight)
	{
		float3 diffuse = ( ( (AmbientDiffuse * aAmbientIntensity) + aDiffuseLight) * aProperties._Diffuse) * HdrRange_Time_ClipHeight.x;
		float3 specular = aSpecularLight;
		return (diffuse + specular);
	}

	//-------------------------------
	// Debugging --------------------
	//-------------------------------
	//#define PDX_DEBUG_NORMAL
	//#define PDX_DEBUG_DIFFUSE
	//#define PDX_DEBUG_SPEC
	//#define PDX_DEBUG_GLOSSINESS
	//#define PDX_DEBUG_SHADOW
	//#define PDX_DEBUG_SUN_LIGHT
	//#define PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
	//#define PDX_DEBUG_SYSTEM_LIGHT
	//#define PDX_DEBUG_AMBIENT
	void DebugReturn(inout float3 aReturn, LightingProperties aProperties, float aShadowTerm)
	{
	#ifdef PDX_DEBUG_NORMAL
		aReturn = saturate(aProperties._Normal);
	#endif

	#ifdef PDX_DEBUG_DIFFUSE
		aReturn = aProperties._Diffuse;
	#endif

	#ifdef PDX_DEBUG_SPEC
		aReturn = aProperties._SpecularColor;
	#endif

	#ifdef PDX_DEBUG_GLOSSINESS
		aReturn = vec3(aProperties._Glossiness);
	#endif

	#ifdef PDX_DEBUG_SHADOW
		aReturn = vec3(aShadowTerm * 0.5f);
	#endif

	#if defined(PDX_DEBUG_SUN_LIGHT) || defined (PDX_DEBUG_SUN_LIGHT_WITH_SHADOW)
		float3 diffuseLight = vec3(0.0);
		float3 specularLight = vec3(0.0);
		aProperties._Diffuse = vec3(0.5);

		#ifdef PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
			CalculateSunLight(aProperties, aShadowTerm, diffuseLight, specularLight);
		#else
			CalculateSunLight(aProperties, 1.0, diffuseLight, specularLight);
		#endif

		aReturn = ComposeLight(aProperties, 1.0f, diffuseLight, specularLight);
	#endif

	#ifdef PDX_DEBUG_SYSTEM_LIGHT
		float3 diffuseLight = vec3(0.0);
		float3 specularLight = vec3(0.0);
		aProperties._Diffuse = vec3(1.0);
		CalculateSystemPointLight(aProperties, 1.0, diffuseLight, specularLight);
		aReturn = ComposeLight(aProperties, 1.0f, diffuseLight, specularLight);
	#endif

	#ifdef PDX_DEBUG_AMBIENT
		aReturn = AmbientDiffuse * aProperties._Diffuse;
	#endif

	#ifdef PDX_DEBUG_CAMERA_LIGHTS
		float3 diffuseLight = vec3(0.0);
		float3 specularLight = vec3(0.0);
		aProperties._Diffuse = vec3(1.0);
		CalculateCameraLights( aProperties, 1.0f, diffuseLight, specularLight );
		aReturn = ComposeLight( aProperties, 1.0f, diffuseLight, specularLight );
	#endif
	}

	float3 UnpackRRxGNormal(float4 NormalMapSample)
	{
		float x = NormalMapSample.g * 2.0 - 1.0;
		float y = NormalMapSample.a * 2.0 - 1.0;
		y = -y;
		float z = sqrt(saturate(1.0 - x * x - y * y));
		return float3(x, y, z);
	}
		//#define PDX_FOUR_SPLITS
	#ifdef PDX_FOUR_SPLITS
	static const float2 shadowMapSize = float2(2048.0f, 2048.0f);
	#else
	static const float2 shadowMapSize = float2(3072.0f, 1024.0f);
	#endif

	float GetShadowPCF( float4 vShadowProj, float vZBias, sampler2DShadow ShadowSample )
	{
		float fShadowTerm1 = tex2Dproj( ShadowSample, vShadowProj ).r < (vShadowProj.z - vZBias) ? 0.0f : 1.0f;
		float fShadowTerm2 = tex2Dproj( ShadowSample, vShadowProj + float4( 1.0f / shadowMapSize.x, 0.0f, 0.0f, 0.0f ) ).r < (vShadowProj.z - vZBias) ? 0.0f : 1.0f;
		float fShadowTerm3 = tex2Dproj( ShadowSample, vShadowProj + float4( 0.0f, 1.0f / shadowMapSize.y, 0.0f, 0.0f ) ).r < (vShadowProj.z - vZBias) ? 0.0f : 1.0f;
		float fShadowTerm4 = tex2Dproj( ShadowSample, vShadowProj + float4( 1.0f / shadowMapSize.x, 1.0f / shadowMapSize.y, 0.0f, 0.0f ) ).r < (vShadowProj.z - vZBias) ? 0.0f : 1.0f;

		float2 f = frac(vShadowProj.xy * shadowMapSize);
		//return fShadowTerm1;
		return lerp(lerp(fShadowTerm1, fShadowTerm2, f.x), lerp(fShadowTerm3, fShadowTerm4, f.x), f.y);
	}

	float GetShadowMultiTap( float4 vShadowProj, float vZBias, sampler2DShadow ShadowSample )
	{
		float2 fTexelSize = float2(0.7f / shadowMapSize.x, 0.7f / shadowMapSize.y);
		float4 shadowFactor;
		shadowFactor.x = GetShadowPCF(vShadowProj + float4( -fTexelSize.x, 0.0f, 0.0f, 0.0f ), vZBias, ShadowSample);
		shadowFactor.y = GetShadowPCF(vShadowProj + float4( 0.0f, fTexelSize.y, 0.0f, 0.0f ), vZBias, ShadowSample);
		shadowFactor.z = GetShadowPCF(vShadowProj + float4( fTexelSize.x, 0.0f, 0.0f, 0.0f ), vZBias, ShadowSample);
		shadowFactor.w = GetShadowPCF(vShadowProj + float4( 0.0f, -fTexelSize.y, 0.0f, 0.0f ), vZBias, ShadowSample);
		return dot(shadowFactor, float4(0.25f, 0.25f, 0.25f, 0.25f));
	}

	float GetShadow( float4 vShadowProj, float vZBias, sampler2DShadow ShadowSample )
	{
	#define SHADOW_MULTI_TAP
	#ifdef SHADOW_MULTI_TAP
		return GetShadowMultiTap(vShadowProj, vZBias, ShadowSample);
	#else
		#ifdef SHADOW_PCF
			return GetShadowPCF(vShadowProj, vZBias, ShadowSample);
		#else
			return tex2Dproj(ShadowSample, vShadowProj).r < (vShadowProj.z - vZBias) ? 0.0f : 1.0f;
		#endif
	#endif
	}

	#ifdef PDX_FOUR_SPLITS
	static const float4 scale = float4(0.5, 0.5, 1, 1);
	static const float4 offset1 = float4(0.5, 0.0, 0, 0);
	static const float4 offset2 = float4(0.0, 0.5, 0, 0);
	static const float4 offset3 = float4(0.5, 0.5, 0, 0);
	#else
	static const float4 scale = float4(1.0 / 3.0, 1, 1, 1);
	static const float4 offset1 = float4(1.0 / 3.0, 0, 0, 0);
	static const float4 offset2 = float4(2.0 / 3.0, 0, 0, 0);
	#endif

	float CalculateShadowCascaded( float3 WorldSpacePos, sampler2DShadow ShadowMap_ )
	{
		float4 WorldPos = float4(WorldSpacePos, 1.0f);
		
		float zBias = 0.001f;
		float4 shadowCoord = float4(0, 0, 0, 1);
		shadowCoord.x = dot(ShadowMapTextureMatrix0XAxis, WorldPos);
		shadowCoord.y = dot(ShadowMapTextureMatrix0YAxis, WorldPos);
			
		float2 edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
		const float cutoff = 2.0f / 1024.0f;
		if (edge.x < cutoff || edge.y < cutoff)
		{
			shadowCoord.x = dot(ShadowMapTextureMatrix1XAxis, WorldPos);
			shadowCoord.y = dot(ShadowMapTextureMatrix1YAxis, WorldPos);
			
			edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
			if (edge.x < cutoff || edge.y < cutoff)
			{
				shadowCoord.x = dot(ShadowMapTextureMatrix2XAxis, WorldPos);
				shadowCoord.y = dot(ShadowMapTextureMatrix2YAxis, WorldPos);
				
	#ifdef PDX_FOUR_SPLITS
				edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
				if (edge.x < cutoff || edge.y < cutoff)
				{
					shadowCoord.x = dot(ShadowMapTextureMatrix3XAxis, WorldPos);
					shadowCoord.y = dot(ShadowMapTextureMatrix3YAxis, WorldPos);
					
					edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
					if (edge.x > cutoff && edge.y > cutoff)
					{
						shadowCoord.z = dot(ShadowMapTextureMatrix3ZAxis, WorldPos);
						shadowCoord = shadowCoord * scale + offset3;
					}
				}
				else
				{
					shadowCoord.z = dot(ShadowMapTextureMatrix2ZAxis, WorldPos);
					shadowCoord = shadowCoord * scale + offset2;
					zBias = 0.0006f;
				}
	#else				
				edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
				if (edge.x > cutoff && edge.y > cutoff)
				{
					shadowCoord.z = dot(ShadowMapTextureMatrix2ZAxis, WorldPos);
					shadowCoord = shadowCoord * scale + offset2;
					zBias = 0.0006f;
				}
	#endif
			}
			else
			{
				shadowCoord.z = dot(ShadowMapTextureMatrix1ZAxis, WorldPos);
				shadowCoord = shadowCoord * scale + offset1;
				zBias = 0.0004f;
			}
		}
		else
		{
			shadowCoord.z = dot(ShadowMapTextureMatrix0ZAxis, WorldPos);
			shadowCoord = shadowCoord * scale;
			zBias = 0.0003f;
		}
		
		return GetShadow(shadowCoord, zBias, ShadowMap_);
	}

	float3 CalculateShadowCascadedDebugColor( float3 WorldSpacePos )
	{
		float4 WorldPos = float4(WorldSpacePos, 1.0f);
		
		float3 retColor = float3(1,0,0);
		
		float2 shadowCoord;
		shadowCoord.x = dot(ShadowMapTextureMatrix0XAxis, WorldPos);
		shadowCoord.y = dot(ShadowMapTextureMatrix0YAxis, WorldPos);

		float2 edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
		const float cutoff = 2.0f / 1024.0f;
		if (edge.x < cutoff || edge.y < cutoff)
		{
			retColor = float3(0,1,0);
			
			shadowCoord.x = dot(ShadowMapTextureMatrix1XAxis, WorldPos);
			shadowCoord.y = dot(ShadowMapTextureMatrix1YAxis, WorldPos);
			
			edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
			if (edge.x < cutoff || edge.y < cutoff)
			{
				retColor = float3(0,0,1);
			
				shadowCoord.x = dot(ShadowMapTextureMatrix2XAxis, WorldPos);
				shadowCoord.y = dot(ShadowMapTextureMatrix2YAxis, WorldPos);
				
				edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
				if (edge.x < cutoff || edge.y < cutoff)
				{
	#ifdef PDX_FOUR_SPLITS
					retColor = float3(1,1,0);
					
					shadowCoord.x = dot(ShadowMapTextureMatrix3XAxis, WorldPos);
					shadowCoord.y = dot(ShadowMapTextureMatrix3YAxis, WorldPos);
								
					edge = min(shadowCoord.xy, float2(1.0, 1.0) - shadowCoord.xy);
					if (edge.x < cutoff || edge.y < cutoff)
					{
						retColor = float3(0,0,0);
					}
	#else
					retColor = float3(0,0,0);
	#endif
				}
			}
		}
		
		return retColor;
	}

		static const float2 INV_LIGHT_INDEX_TEXTURE_SIZE = float2(1.0 / 64.0, 1.0 / 64.0);
	static const float INV_LIGHT_DATA_TEXTURE_SIZE = float(1.0 / 128.0);

	float2 GetLightIndexUV(float3 WorldSpacePos)
	{
		float2 XZ = WorldSpacePos.xz;
		XZ -= GridStart_InvCellSize.xy;
		
		float2 cellIndex = XZ * GridStart_InvCellSize.zw;
		return cellIndex * INV_LIGHT_INDEX_TEXTURE_SIZE;
	}

	void CalculatePointLights(LightingProperties aProperties, in sampler2D LightData_, in sampler2D LightIndexMap_, inout float3 aDiffuseLightOut, inout float3 aSpecularLightOut)
	{
		float4 vScreenSpace = mul( ViewProjectionMatrix, float4(aProperties._WorldSpacePos,1.0f) );
		
		float4 vScreenCoord;
		vScreenCoord.x = ( vScreenSpace.x * 0.5 + vScreenSpace.w * 0.5 );
		vScreenCoord.y = ( vScreenSpace.w * 0.5 + vScreenSpace.y * 0.5 );
		vScreenCoord.zw = vScreenSpace.ww;
		float4 LightIndices = tex2Dproj(LightIndexMap_, vScreenCoord );
		
		for (int i = 0; i < 4; ++i)
		{
			float LightIndex = LightIndices[i] * 255.0;
			if (LightIndex >= 255.0)
				break;
			
			float4 LightData1 = tex2Dlod(LightData_, float4((LightIndex * 2 + 0.5) * INV_LIGHT_DATA_TEXTURE_SIZE, 0, 0, 0));
			float4 LightData2 = tex2Dlod(LightData_, float4((LightIndex * 2 + 1.5) * INV_LIGHT_DATA_TEXTURE_SIZE, 0, 0, 0));
			PointLight pointlight = GetPointLight(LightData1, LightData2);
				
			CalculatePointLight(pointlight, aProperties, aDiffuseLightOut, aSpecularLightOut);
		}
	}

	float3 ApplyDissolve( float3 vPrimaryColorIn, float vDissolveIn, float3 vColor, float3 vDiffuse, float2 vUV )
		{
			float vDissolveTex = tex2D( CustomTexture2, vUV ).r;
			float vTime = -vDissolveIn;
			//float vTime = saturate( frac( HdrRange_Time_ClipHeight.y ) * 1.1f );
			const float vTimeOffset = 1.3f;
			float vD = vTimeOffset - vTime * vTimeOffset - vDissolveTex - 0.01f;
			clip( vD );

			const float EDGE_SHARPNESS = 3.0f;
			const float EDGE_POW = 5.0f;
			const float COLOR_INTENSITY = 10.0f;

			float NdotU = dot( UnpackRRxGNormal( tex2D( NormalMap, vUV ) ).rgb, float3( 0.f, 1.f, 0.f ) ) * 0.5f + 0.5f;

			float3 AddColor = vPrimaryColorIn * COLOR_INTENSITY;
			return vColor + AddColor * NdotU * pow( saturate( 1.f - vD*EDGE_SHARPNESS ), EDGE_POW );
		}
	float3 ApplyPlanetDissolve( float3 vPrimaryColor, float3 vColor, float3 vNormal, float2 vUV, float vDissolve )
		{
			// Arbitrary value for signaling that the effect shouldn't be applied
			if ( vDissolve < -9.0f )
			{
				return vColor;
			}

			const float TIME_OFFSET = 0.95f;

			float vTex = texCUBE( LavaNoise, vNormal ).r;
			float vDot = 0.25f + ( 0.25f * dot( vNormal, float3( 0.0f, 1.0f, 0.0f ) ) );
			float vNoise = ( vTex * 0.25f ) + vDot;
			float vDissolveAbs = abs( vDissolve );

			// Move the "clipping edge" down the planet
			float vD = TIME_OFFSET - vNoise - ( saturate( vDissolveAbs ) * TIME_OFFSET );
			if ( vDissolve < 0 )
			{
				clip( -vD );
			}
			else
			{
				clip( vD );
			}

			const float EDGE_SHARPNESS = 2.0f;
			const float EDGE_POW = 10.0f;
			const float COLOR_INTENSITY = 20.0f;
			const float FADE_OUT_POINT = 0.9f;

			float NdotU = ( dot( UnpackRRxGNormal( tex2D( NormalMap, vUV ) ).rgb, float3( 0.f, 1.f, 0.f ) ) * 0.5f ) + 0.5f;

			float3 vAddColor = vPrimaryColor * vPlanetDissolveColorMult * COLOR_INTENSITY;
			vAddColor *= NdotU * pow( saturate( 1.0f - ( abs( vD ) * EDGE_SHARPNESS ) ), EDGE_POW );

			// Fade out the edge glow effect at the end
			if ( vDissolveAbs > FADE_OUT_POINT )
			{
				vAddColor -= vAddColor * ( ( vDissolveAbs - FADE_OUT_POINT ) / ( 1.0f - FADE_OUT_POINT ) );
			}

			return vColor + vAddColor;
		}

		float4 main( VS_OUTPUT_PDXMESHSTANDARD In ) : PDX_COLOR
		{
			const float MAX_BUILDINGS_FOR_NIGHT_LIGHTS = 14;

			float3 vPos = In.vPos.xyz / In.vPos.w;

			LightingProperties lightingProperties;
			lightingProperties._WorldSpacePos = vPos;
			lightingProperties._ToCameraDir = normalize(vCamPos - vPos);

			float3 vInNormal = normalize( In.vNormal );
			float4 vNormalMap = tex2D( NormalMap, In.vUV0 );

			float4 vProperties = tex2D( SpecularMap, In.vUV0 );

		#ifdef IS_PLANET
			PointLight systemPointlight = GetPointLight(SystemLightPosRadius, SystemLightColorFalloff);
		#endif

		#ifdef USE_FLOWMAP
			float3 vNormal = vInNormal;
			float flowmapIntensity = 0.05f;
			vNormalMap.xy = ( ( vNormalMap.xy - 0.5f ) * 2.0f ) * flowmapIntensity;

			float2 flowUVs = In.vUV0 + ( vNormalMap.xy * frac( vUVAnimationTime ) );
			float2 offsetFlowUVs = In.vUV0 + ( vNormalMap.xy * frac( vUVAnimationTime + 0.5f ) );
			float blendValue = abs( ( frac( vUVAnimationTime ) * 2.0f ) - 1.0f );

			float4 vDiffuse = tex2D( DiffuseMap, flowUVs );
			float4 vDiffuseOffset = tex2D( DiffuseMap, offsetFlowUVs );
			vDiffuse = lerp( vDiffuse, vDiffuseOffset, blendValue );
		#else
			float4 vDiffuse = tex2D( DiffuseMap, In.vUV0 + vUVAnimationDir * vUVAnimationTime );
			#ifdef IS_CLOUDS
				// Clip clouds at planet limit
				clip( saturate( dot( vInNormal, lightingProperties._ToCameraDir ) ) - 0.27f );

				// Bend normals for clouds to reduce edge
				float3 vSystemLightDir = normalize( systemPointlight._Position - vPos );
				vInNormal = normalize( lerp( vInNormal, vSystemLightDir, 0.01f + 0.10f * vDiffuse.a ) );
			#endif
			float3x3 TBN = Create3x3( normalize( In.vTangent ), normalize( In.vBitangent ), vInNormal );
			float3 vNormalSample = UnpackRRxGNormal( vNormalMap );
			float3 vNormal = normalize( mul( vNormalSample, TBN ) );
		#endif

		#ifdef GUI_ICON
			#ifndef IS_CLOUDS
				vDiffuse.rgb = GreyOutDotLerp( vDiffuse.rgb, 0.4f );
			#endif
		#endif

		#ifdef ALPHA_TEST
			clip(vDiffuse.a - 1.0);
		#endif

			float alpha = vDiffuse.a;

			lightingProperties._Glossiness = vProperties.a;
			lightingProperties._NonLinearGlossiness = GetNonLinearGlossiness( lightingProperties._Glossiness );
			lightingProperties._Normal = vNormal;

			float vCubemapIntensity = CubemapIntensity;

		#ifdef EMISSIVE
			float vEmissive = vNormalMap.b;
			#ifndef USE_EMPIRE_COLOR_MASK_FOR_EMISSIVE //If not defined, just color all of the emissive the empire color
				if( AtmosphereColor.a > 0.0f )
				{
					vDiffuse.rgb = lerp( vDiffuse.rgb, vec3( max( vDiffuse.r, max( vDiffuse.g, vDiffuse.b ) ) ) * AtmosphereColor.rgb, saturate( (vEmissive ) ) );
				}
			#else
				if( AtmosphereColor.a > 0.0f ) //It is defined, therefore we take the empire color map into account and only color areas that have been defined there as well.
				{
					float Floored = floor( vProperties.r + 0.95f );
					float3 EmpireColorEmissive = float3(Floored, Floored, Floored);
					vDiffuse.rgb = lerp( vDiffuse.rgb, vec3( max( vDiffuse.r, max( vDiffuse.g, vDiffuse.b ) ) ) * AtmosphereColor.rgb, saturate( (vEmissive * EmpireColorEmissive ) ) );
				}
			#endif
		#endif

			float3 vColor = vDiffuse.rgb;
		#ifndef ADD_COLOR //Adds empire/atmosphere color to parts of mesh, depending on mask
			if( AtmosphereColor.a > 0.0f )
			{
		#endif
				// Gamma - Linear ping pong
				// All content is already created for gamma space math, so we do this in gamma space
				vColor = ToGamma(vColor);
				vColor = ToLinear(lerp( vColor, vColor * ( vProperties.r * AtmosphereColor.rgb ), vProperties.r ));
		#ifndef ADD_COLOR
			}
		#endif

			float SpecRemapped = vProperties.g * vProperties.g * 0.4;
			float MetalnessRemapped = 1.0 - (1.0 - vProperties.b) * (1.0 - vProperties.b);
			lightingProperties._Diffuse = MetalnessToDiffuse(MetalnessRemapped, vColor);
			lightingProperties._SpecularColor = MetalnessToSpec(MetalnessRemapped, vColor, SpecRemapped);

			float3 diffuseLight = vec3(0.0);
			float3 specularLight = vec3(0.0);

			CalculateSystemPointLight(lightingProperties, 1.0f, diffuseLight, specularLight);
			CalculatePointLights(lightingProperties, LightDataMap, LightIndexMap, diffuseLight, specularLight);


		#ifdef EMISSIVE
			#ifndef IS_RING
				#ifndef NO_PLANET_EMISSIVE
					#ifndef PLANET_LIGHTS_EMISSIVE
						#ifdef IS_PLANET
							// Emissive only on dark side of planets
							float3 vSystemLightDir = normalize( systemPointlight._Position - lightingProperties._WorldSpacePos );
							float NdotL = saturate( saturate( dot( vInNormal, -vSystemLightDir ) - 0.05f ) * 5.0f );

							float vDarksideEmissive = 1.0f - saturate( length( diffuseLight + specularLight ) );
							vEmissive *= vDarksideEmissive * vProperties.r * NdotL;

							vCubemapIntensity *= ( 1.0f - vDarksideEmissive ) / 2.0f;
						#endif
					#else // PLANET_LIGHTS_EMISSIVE
						float vDarksideEmissive = 1.0f;
					#endif
				#endif
			#endif
		#endif

			float3 vEyeDir = normalize( vPos - vCamPos.xyz );
			float3 reflection = reflect( vEyeDir, vNormal );
			float MipmapIndex = GetEnvmapMipLevel(lightingProperties._Glossiness);

			float3 reflectiveColor = texCUBElod( EnvironmentMap, float4(reflection, MipmapIndex) ).rgb * vCubemapIntensity;
			specularLight += reflectiveColor * FresnelGlossy(lightingProperties._SpecularColor, -vEyeDir, lightingProperties._Normal, lightingProperties._Glossiness);

			vColor = ComposeLight(lightingProperties, 1.0f, diffuseLight, specularLight);

		#ifdef EMISSIVE
			vColor = lerp( vColor, vDiffuse.rgb, vEmissive );

			#ifndef IS_RING
				#ifndef NO_PLANET_EMISSIVE
					#ifdef IS_PLANET

						float4 vCityColor = tex2D( CustomTexture, In.vUV0 );
						float vLights = ( Colonized / MAX_BUILDINGS_FOR_NIGHT_LIGHTS );

						float vBrightness = vDarksideEmissive * vProperties.r * dot( vCityColor.rgb, vec3( 0.5 ) );
						const float NUM_STEPS = 4;
						vLights = floor( ( 0.99f / NUM_STEPS + vLights ) * NUM_STEPS ) / (NUM_STEPS-1);
						vBrightness *= saturate( ( vLights - (1.f-vCityColor.a) ) * NUM_STEPS );
						vColor = saturate( vColor + vCityColor.rgb * vBrightness );
						vEmissive = max( vEmissive, vBrightness );
					#endif
				#endif
			#endif

			#ifndef GUI_ICON
				#ifndef NO_ALPHA_MULTIPLIED_EMISSIVE
					alpha *= vEmissive;
				#endif
			#endif
		#endif

		#ifndef IS_RING
			#ifdef IS_PLANET
				#ifdef GUI_ICON
					const float vWidth = 2.1f;
					const float vIntensity = 0.85f;
					float vAtmosphere = saturate( dot( vInNormal, -lightingProperties._ToCameraDir ) + AtmosphereWidth * vWidth ) * vIntensity;
				#else
					float vToCamera = saturate( dot( vInNormal, -lightingProperties._ToCameraDir ) + AtmosphereWidth);
					float vToSun = dot( vInNormal, normalize( SystemLightPosRadius.xyz - vPos ) ) * 0.5f + 0.5f;
					float vAtmosphere = lerp( vToCamera, vToCamera * vToSun, 0.5f );
				#endif
				vColor = lerp( vColor, AtmosphereColor.rgb, vAtmosphere * vAtmosphere * AtmosphereColor.a * AtmosphereIntensity );
			#endif
		#endif

		#ifdef IS_PLANET
			#ifdef GUI_ICON
				vColor = vColor * Sensor + float3( 0.3f, 0.3f, 0.3f ) * ( 1.0f - Sensor );
				#ifdef IS_RING
					alpha *= 4.5f;
				#endif
			#else
				vColor = vColor * Sensor + ToLinear( float3( 0.3f, 0.3f, 0.3f ) * ( 1.0f - Sensor ) );
			#endif
		#endif

		#ifdef RIM_LIGHT
			float vRim = smoothstep( RIM_START, RIM_END, 1.0f - dot( vInNormal, lightingProperties._ToCameraDir ) );
			vColor.rgb = lerp( vColor.rgb, RIM_COLOR.rgb, vRim );
		#endif
			vColor.rgb *= vBloomFactor;

		#ifdef DISSOLVE
			vColor.rgb = ApplyDissolve( AtmosphereColor.rgb, 0.0f, vColor.rgb, AtmosphereColor.rgb, In.vUV0 );
		#endif

		#ifndef IS_RING
			#ifdef IS_PLANET
				vColor.rgb = ApplyPlanetDissolve( AtmosphereColor.rgb, vColor.rgb, In.vNormal, In.vUV0, vPlanetDissolveTime );
			#endif
		#endif

			return float4(vColor, alpha);
		}

	